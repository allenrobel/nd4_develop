{
    "requirements": {
        "ansible_module_conventions": [
            "Follow standard Ansible module structure.",
            "Use `AnsibleModule` to handle module arguments and return results.",
            "Include proper docstrings for the module and relevant functions.",
            "Handle errors gracefully and return informative error messages in the output."
        ],
        "dependencies": [
            "Use Pydantic (Version 2 or higher) to validate all payloads, controller responses, and playbook config data."
        ],
        "functionality": "The module should connect to a Nexus Dashboard version 3 server using a connection plugin that is already defined for this project.",
        "inputs": {
            "config": "This is the Ansible playbook `config` field. `config` is a list of dictionaries, where each dictionary contains the field(s) that define a VRF configuration.",
            "hostname": "Is already defined in the Ansible inventory and is not required by the Ansible module you are writing.",
            "password": "Is already defined in the Ansible inventory and is not required by the Ansible module you are writing.",
            "state": "The Ansible state associated with the config. For example, deleted state should result in the Deleted() class being called.",
            "username": "Is already defined in the Ansible inventory and is not required by the Ansible module you are writing."
        },
        "output_format": "Provide the complete Python code for the module in a code block. Include a brief explanation of the code and how to use the module within an Ansible playbook.",
        "outputs": [
            "Return a JSON dictionary containing the standard output and standard error of the executed command.",
            "Indicate whether the command executed successfully or failed."
        ],
        "planning_note": "Think step-by-step to plan the module structure, including handling arguments, determining the state to be used, and returning the results in the specified format.",
        "python_coding_conventions": [
            "Use type hints for all method/function signatures and variables.",
            "Clean separation of concerns.",
            "Methods should be short, and follow the single responsibility principle.",
            "Use composition over inheritance.",
            "Use dependency injection where it makes sense.",
            "Use Python 3.9+ modern type hinting syntax rather than objects (Dict, List, etc) from the typing library."
        ]
    },
    "role": {
        "description": "You are an expert Python and Ansible developer specializing in Ansible module creation. You are passionate about best practice coding, including concepts such as dependency injection, separation of concerns, single responsibility, modularity, intuitive and consistent method and variable names, etc. You favor composition over inheritance. You love generating beautiful code that others can easily understand and maintain, and that is extensible."
    },
    "task": {
        "description": "Your task is to create an Ansible module, written in Python 3.12 or higher. The module will manage Nexus Dashboard VRFs and will handle the following Ansible states.",
        "note": "If you have questions about what a given state should do, please feel free to ask!",
        "state_implementation": {
            "classes": [
                "Deleted",
                "Merged",
                "Overridden",
                "Query",
                "Replaced"
            ],
            "description": "Each state should be implemented in a separate class with corresponding names."
        },
        "states": [
            "deleted",
            "merged",
            "overridden",
            "query",
            "replaced"
        ]
    }
}